/******/

// webpackBootstrap

// install a JSONP callback for chunk loading

// add entry modules from loaded chunk to deferred list

// run deferred modules when all chunks ready

// The module cache

// object to store loaded and loading chunks

// undefined = chunk not loaded, null = chunk preloaded/prefetched

// Promise = chunk loading, 0 = chunk loaded

// The require function

// Check if module is in cache

// Create a new module (and put it into the cache)

// Execute the module function

// Return the exports of the module

// Flag the module as loaded

// expose the modules object (__webpack_modules__)

// expose the module cache

// define getter function for harmony exports

// define __esModule on exports

// create a fake namespace object

// mode & 1: value is a module id, require it

// mode & 2: merge all properties of value into the ns

// mode & 4: return value when already ns object

// mode & 8|1: behave like require

// getDefaultExport function for compatibility with non-harmony modules

// Object.prototype.hasOwnProperty.call

// __webpack_public_path__

// add entry module to deferred list

// run deferred modules when ready

/************************************************************************/

/* 0 */

/* 1 */

/***/

/* 2 */

/* 3 */

// extracted by mini-css-extract-plugin

/* 4 */

// ESM COMPAT FLAG

// EXTERNAL MODULE: ./src/styles/main.scss

// EXTERNAL MODULE: ./node_modules/three/build/three.module.js

// When the image target named 'model-target' is detected, show 3D model.

// This string must match the name of the image target uploaded to 8th Wall.

// if (detail.name === 'model-target') {

//   model.position.copy(detail.position)

//   model.quaternion.copy(detail.rotation)

//   model.scale.set(detail.scale, detail.scale, detail.scale)

//   model.visible = true

// }

// When the image target named 'video-target' is detected, play video.

// Camera pipeline modules need a name. It can be whatever you want but must be

// unique within your app.

// onStart is called once when the camera feed begins. In this case, we need to wait for the

// XR8.Threejs scene to be ready before we can access it to add content. It was created in

// XR8.Threejs.pipelineModule()'s onStart method.

// Get the 3js scene from XR

// create the video element

// Hide video until image target is detected.

// Load 3D model

// loader.load(

//   // resource URL

//   modelFile,

//   // loaded handler

//   (gltf) => {

//     model = gltf.scene

//     scene.add(model)

//     // Hide 3D model until image target is detected.

//     model.visible = false

//   },

//   // progress handler

//   (xhr) => {

//     console.log(`${(xhr.loaded / xhr.total) * 100}% loaded`)

//   // error handler

//   (error) => {

//     console.log('Error loading .glb model:', error)

//   }

// )

// Add soft white light to the scene.

// This light cannot be used to cast shadows as it does not have a direction.

// Set the initial camera position relative to the scene we just laid out. This must be at a

// height greater than y=0.

// Add content to the scene and set starting camera position.

// Sync the xr controller's 6DoF position and camera paremeters with our scene.

// Listeners are called right after the processing stage that fired them. This guarantees that

// updates can be applied at an appropriate synchronized point in the rendering cycle.

// If your app only interacts with image targets and not the world, disabling world tracking can

// improve speed.

// Add camera pipeline modules.

// Existing pipeline modules.

// Draws the camera feed.

// Creates a ThreeJS AR Scene.

// Enables SLAM tracking.

// Detects unsupported browsers and gives hints.

// Modifies the canvas to fill the window.

// Manages the loading screen on startup.

// Shows an error image on runtime error.

// Custom pipeline modules.

// Open the camera and start running the camera run loop.
